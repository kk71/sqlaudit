[
    {
        "name": "TOOMANY_IN_LIST",
        "desc": "IN List元素过多",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [
            {
                "name": "in_list_num",
                "desc": "inlist元素个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 20
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs[\"single_sql\"]\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    sql_content = [\n        x\n        for x in re.findall(r\"\\s+in\\s+\\((.*?)\\)\", sql_text, re.I+re.S)\n        if 'select' not in x.lower()\n    ]\n    for value in sql_content:\n        if value.count(\",\") >= rule.gip(\"in_list_num\") - 1:\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "IN List元素过多",
        "solution": [
            "改用临时表存入变量"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "DML_DDL_MIXED",
        "desc": "DML和DDL语句混写",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "DML",
            "DDL"
        ],
        "input_params": [],
        "output_params": [],
        "code": "from parsed_sql import const\n\n\ndef code(rule, entries, **kwargs):\n    sqls: [dict] = kwargs.get(\"sqls\")\n\n    sql_types: set = {i[\"sql_type\"] for i in sqls}\n    if const.SQL_DDL in sql_types and const.SQL_DML in sql_types:\n        yield {}\n\n\ncode_hole.append(code)\n",
        "status": false,
        "summary": "DML、DDL语句混写会导致上线失败回滚时，DDL无法回滚",
        "solution": [
            "建议拆分DDL和DML语句"
        ],
        "weight": 0.1,
        "max_score": 5,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "BAD_JOIN",
        "desc": "存在全连接或外连接",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    cross_outer_join = re.compile(r\"(cross join)|(outer join)\", re.M+re.I)\n\n    if cross_outer_join.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存在全连接或外连接,cross join或outer join情况",
        "solution": [
            "改写为inner join"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_ADD_COLUMN",
        "desc": "添加字段无默认值",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'alter\\s+table\\s+.+\\s+add', sql_text, re.I+re.M):\n        if not re.search(r\".+\\s+default\\s+.+\", sql_text, re.I+re.M):\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            "尽可能在添加字段的时候指定默认值"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_BITMAP_INDEX",
        "desc": "位图索引",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\nfrom cmdb.const import MODEL_OLTP\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    cmdb = kwargs.get(\"cmdb\")\n    db_model = cmdb.db_model\n\n    if db_model == MODEL_OLTP and\\\n            re.search(r\"create\\s+bitmap\\s+index\", sql_text, re.I+re.M):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_COLUMN_NUMBER",
        "desc": "表字段数",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    \"\"\"列数\"\"\"\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if not re.search(r\"create\\s+table\", sql_text, re.I+re.M):\n        return\n\n    left_brackets = 0\n    left_flag = 0\n    right_flag = 0\n    for index, s in enumerate(sql_text):\n        if s == \"(\":\n            left_brackets += 1\n            if left_brackets == 1:\n                left_flag = index\n        elif s == \")\":\n            left_brackets -= 1\n            if left_brackets == 0:\n                right_flag = index\n                break\n\n    sql = sql_text[left_flag + 1: right_flag]\n\n    if len(sql.split(',')) > 255:  # TODO,这不应写死\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_CONCURRENCY_LEVEL",
        "desc": "并行度",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if not re.search(r\"create\\s+table\", sql_text, re.I+re.M):\n        return\n\n    if 'parallel' not in sql_text.lower():\n        return\n    parallel = re.search(r\"parallel\\s+(\\d)\", sql_text, re.I+re.M)\n    if parallel and int(parallel.group(1)) > 1:\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_CREATE_TABLE_NOT_DEFINE_TABLE_SPACE",
        "desc": "创建表未指定表空间",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'create\\s+table', sql_text, re.I+re.M) and\\\n            'tablespace' not in sql_text.lower():\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_DB_LINK_CREATED",
        "desc": "创建数据库链接",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'create\\s+database\\s+link', sql_text, re.I+re.M):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_DB_LINK_OFFLINE",
        "desc": "存在DBLINK",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search('@', sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_DELETE",
        "desc": "存在delete语句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    for token in this_one_sql.tokens:\n        if token.normalized == \"DELETE\":\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n            return\n\n\ncode_hole.append(code)\n\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_DROP",
        "desc": "存在drop语句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    for token in this_one_sql.tokens:\n        if token.normalized == \"DROP\":\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n            return\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_INDEX_NOT_DEFINE_TABLE_SPACE",
        "desc": "索引未定义表空间",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'create\\s+index', sql_text, re.I+re.M) and\\\n            'tablespace' not in sql_text.lower():\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_INDEX_ONLINE",
        "desc": "创建索引时未带上online关键字",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'create\\s+index\\s+', sql_text, re.I+re.M):\n        if not re.search(r\"\\s+online\", sql_text, re.I+re.M):\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "创建索引的时候加上online,否则索引创建期间会锁表",
        "solution": [
            "创建索引的时候加上online"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_LOB_USING",
        "desc": "LOB使用",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if (\n            not re.search(r\"create\\s+table\", sql_text, re.I)\n            and not re.search(r\"alter\\s+table\", sql_text, re.I)\n    ) or any([\n        x in sql_text.lower()\n        for x in ['blob', 'clob', 'bfile', 'xmltype']\n    ]):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_MODIFY_COLUMN",
        "desc": "修改字段类型",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'alter\\s+table\\s+.+\\s+modify', sql_text, re.I+re.M):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_SEQUENCE",
        "desc": "序列",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if not re.search(r\"create\\s+sequence\", sql_text, re.I+re.M):\n        return\n\n    res = re.search(r\"cache\\s+(\\d+)\", sql_text, re.I)\n    if 'order' in sql_text.lower() or\\\n            'cache' not in sql_text.lower() or\\\n            (res and int(res.group(1)) < 2000):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_TRUNCATE",
        "desc": "存在truncate语句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    for token in this_one_sql.tokens:\n        if token.normalized == \"TRUNCATE\":\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n            return\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_USING_REVOKE",
        "desc": "撤回权限",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'revoke\\s+', sql_text, re.I+re.M):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "DML_ALLDATA",
        "desc": "delete或update中缺少where条件",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    pat = re.compile(r'(\\s)?((update )|(delete ))', re.M+re.I)\n    pat1 = re.compile(r'\\s+where\\s+', re.S+re.I)\n\n    if pat.search(sql_text) and not pat1.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "DML_SORT",
        "desc": "delete或update中出现order by子句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    dml_sort = re.compile(r\"(\\s)?((update )|(delete )).*order by\", re.M+re.I)\n\n    if dml_sort.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "LIKE_UNINDEX",
        "desc": "谓词条件使用like %xxx,无法使用索引",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    like_unindex = re.compile(r\"like\\s+\\.?%\", re.M+re.I)\n\n    if like_unindex.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "谓词条件使用like %xxx,无法使用索引",
        "solution": [
            "从业务角度出发,分析是否可使用精确运算符或类似like'xx%'"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "LONG_TEXT",
        "desc": "SQL文本过长",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [
            {
                "name": "char_num",
                "desc": "SQL字符数量",
                "unit": "个",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 5000
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "def code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text\"]\n\n    length = len(sql_text)\n    if length >= rule.gip(\"char_num\"):\n        yield {\n            \"char_num\": length,\n            \"sql_id\": kwargs.get(\"sql_id\", None)\n        }\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "SQL文本过长",
        "solution": [
            "sql改写为精简语句"
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "SELECT_ANY",
        "desc": "使用select *",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    select_any = re.compile(\"(select \\\\*)|(select .*\\\\.\\\\*)\")\n\n    if re.search(select_any, sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "禁止使用select *,必须明确选择所需的列",
        "solution": [
            "使用明确的列"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_FROM",
        "desc": "from段出现子查询",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    has_from = False\n    for token in this_one_sql.tokens:\n        if token.normalized == \"FROM\":\n            has_from = True\n            continue\n        if has_from:\n            if recursively_find_following_select(token):\n                yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "from段出现子查询",
        "solution": [
            "改写为表关联"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_HAVING",
        "desc": "having段出现子查询",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    has_from = False\n    for token in this_one_sql.tokens:\n        if token.normalized == \"HAVING\":\n            has_from = True\n            continue\n        if has_from:\n            if recursively_find_following_select(token):\n                yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "having段出现子查询",
        "solution": [
            "改写为表关联"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_REP",
        "desc": "重复查询子句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "def code(rule, entries, **kwargs):\n    \"\"\"重复查询子句\"\"\"\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    str_len = len(sql_text)\n    left_bracket = []\n    sql_content = []\n    subquery = []\n\n    for i in range(str_len):\n        if sql_text[i] == \"(\":\n            left_bracket.append(i)\n        if sql_text[i] == \")\":\n            start = sum(left_bracket[-1:-2:-1]) + 1\n            stop = i - 1\n            sql_content.append(sql_text[start:stop])\n    for value in sql_content:\n        if \"select\" in value.lower() and value not in subquery:\n            subquery.append(value)\n        elif \"select\" in value.lower() and value in subquery:\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "禁止使用重复的查询子句,应使用with as替换子句(仅限Oracle)来提升SQL执行效率",
        "solution": [
            "1.withas",
            "2.改写sql避免重复查询"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_SELECT",
        "desc": "select段出现子查询",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    has_from = False\n    for token in this_one_sql.tokens:\n        if token.normalized == \"SELECT\":\n            has_from = True\n            continue\n        if has_from:\n            if recursively_find_following_select(token):\n                yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "select段出现子查询",
        "solution": [
            "改写为表关联"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_WHERE",
        "desc": "where段出现子查询",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    has_from = False\n    for token in this_one_sql.tokens:\n        if token.normalized == \"WHERE\":\n            has_from = True\n            continue\n        if has_from:\n            if recursively_find_following_select(token):\n                yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "where段出现子查询",
        "solution": [
            "改写为表关联"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "TOOMANY_BIND",
        "desc": "绑定变量过多",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "DML",
            "DDL",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [
            {
                "name": "num_of_bound_var",
                "desc": "绑定变量个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 50
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "def code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if sql_text.count(\":\") >= rule.gip(\"num_of_bound_var\"):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "绑定变量过多",
        "solution": [
            "减少绑定变量"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TOOMANY_OR",
        "desc": "多个过滤条件通过or连接",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [
            {
                "name": "or_num",
                "desc": "or个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 5
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if len(re.compile(r\"\\s+or\\s+\", re.I+re.M).findall(sql_text))\\\n            >= rule.gip(\"or_num\"):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "多个过滤条件通过or连接,防止优化器出现选择异常",
        "solution": [
            "改用临时表存入变量"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "UNION",
        "desc": "出现union",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    pat = re.compile(r\"\\s+union\\s+\", re.I+re.M)\n\n    if pat.findall(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "出现union,防止出现不必要的排序动作",
        "solution": [
            "改写union和sql逻辑中去重"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "WHERE_FUNC",
        "desc": "查询列上使用表达式",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    where_func = re.compile(r\"where\\s+.*?[+\\-*/()].*[<>=]{1,2}?\", re.I+re.S)\n\n    if where_func.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "禁止在where语句的比较符左侧使用运算表达式，或者函数表达式",
        "solution": [
            "1.运算、函数写在表达式右边",
            "2.应用程序实现函数功能"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "WHERE_NOT",
        "desc": "谓词中存在负向操作符!=等",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    where_not = re.compile(\"(!=)|(<>)|(!>)|(!<)\")\n\n    if re.search(where_not, sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "谓词中存在负向操作符,!=,<>,!<,!>,not exists,not",
        "solution": [
            "1.如果列值是连续,可把否定操作,更改为两个区间",
            "2.不建议使用不等值运算"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_INDEX_FAST_FULL_SCAN",
        "desc": "执行计划中索引快速全扫",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "ind_phy_size",
                "desc": "索引物理大小",
                "unit": "MB",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 100
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"INDEX\",\n        options=\"FAST FULL SCAN\"\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "大索引快速全扫描",
        "solution": [
            "SQL逻辑能否改写获取更少的数据"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_INDEX_FULL_SCAN",
        "desc": "执行计划中索引全扫",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "ind_phy_size",
                "desc": "索引物理大小",
                "unit": "MB",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 1024.0
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "object_name",
                "desc": "对象名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(operation=\"INDEX\", options=\"FULL SCAN\")\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "大索引全扫描",
        "solution": [
            "SQL逻辑能否改写获取更少的数据"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_INDEX_SKIP_SCAN",
        "desc": "执行计划中存在索引跳描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(operation=\"INDEX\", options=\"SKIP SCAN\")\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "索引跳跃扫描",
        "solution": [
            "索引列的先后顺序是否合理"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_MERGE_JOIN_CARTESIAN",
        "desc": "笛卡尔积关联",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"MERGE JOIN\",\n        options=\"CARTESIAN\"\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "笛卡尔积",
        "solution": [
            "1.表关联条件缺失,加上关联条件",
            "2.统计信息不准确,手工收集统计信息"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_PARALLEL_FETCH",
        "desc": "存在并行访问特征",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(operation=\"PX COORDINATOR\")\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存在并行访问特征",
        "solution": [
            "取消表、索引、sql中的并行设置"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_PARTITION_RANGE_ALL",
        "desc": "分区全扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"PARTITION RANGE\",\n        options=\"ALL\"\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "分区全扫描",
        "solution": [
            "分区键设计是否合理"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_PARTITION_RANGE_INLIST_OR",
        "desc": "非连续分区扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"PARTITION RANGE\",\n        options__in=(\"INLIST\", \"OR\")\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "非连续分区扫描",
        "solution": [
            "分区键设计是否合理"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_PARTITION_RANGE_ITERATOR",
        "desc": "跨分区扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"PARTITION RANGE\",\n        options=\"ITERATOR\"\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "跨分区扫描",
        "solution": [
            "分区键设计是否合理"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_TABLE_FULL_SCAN",
        "desc": "全表扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "table_phy_size",
                "desc": "表物理大小",
                "unit": "MB",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 2048
            },
            {
                "name": "table_row_num",
                "desc": "表行数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 100000
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from oracle_cmdb.capture.obj_tab_info import OracleObjTabInfo\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"TABLE ACCESS\",\n        options=\"FULL\",\n        object_type=\"TABLE\"\n    )\n\n    for d in values_dict(qs,\n                         \"sql_id\",\n                         \"plan_hash_value\",\n                         \"object_name\",\n                         \"object_type\",\n                         \"task_record_id\",\n                         \"schema_name\"):\n        the_table = OracleObjTabInfo.objects(\n            task_record_id=d[\"task_record_id\"],\n            schema_name=d[\"schema_name\"],\n            table_name=d[\"object_name\"]\n        ).first()\n        if not the_table:\n            continue\n        if the_table.num_rows >= rule.gip(\"table_row_num\") or\\\n                the_table.phy_size_mb >= rule.gip(\"table_phy_size\"):\n            yield {\n                k: v\n                for k, v in d.items()\n                if k in (\"sql_id\", \"plan_hash_value\", \"object_name\", \"object_type\")\n            }\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "全表扫描",
        "solution": [
            "1.缺索引评估创建索引",
            "2.取max、min值评估创建索引",
            "3.索引失效重建索引,分区表维护记得维护索引",
            "4.对条件字段使用函数或表达式a.函数、表达式放到等于号的右边b.创建函数索引(下策)",
            "5.出现隐式转换a.不同类型的谓词匹配先显式转换b.表定义根据数据选择正确的数据类型",
            "6.使用isNULL做查询条件a.不建议使用null值b.null值较少的情况可创建组合索引或者伪列索引(createindexidx_1ontab1(col1,0)c.将null定义一个普通变量",
            "7.使用不等运算符<>!=做查询条件a.尽量少用不等判断；b.如果列值是连续,可把否定操作更改为两个区间；c.如果列值不多,可用inlist枚举其他所有值",
            "8.'％a％''％a'建议精确匹配",
            "9.sql逻辑,比如最大值,改用窗口函数",
            "10.弱选择sql,返回结果集较大建议a.添加更多的谓词减少数据的访问,比如时间b.改造分区表c.使用覆盖索引",
            "11.hintfull禁用hint1",
            "12.统计信息不准确数据批量加载程序触发收集统计信息"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_TO_CHANGE_TYPE",
        "desc": "隐式转换",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\nfrom rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        filter_predicates=re.compile(\n            r\"(SYS_OP|TO_NUMBER|INTERNAL_FUNCTION)\", re.I)\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "隐式转换",
        "solution": [
            "1.显式转换",
            "2.选择合适的字段类型"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_VIEW_SCAN",
        "desc": "存在视图访问",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\nfrom rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        object_type=\"VIEW\",\n        object_owner__ne=None,\n        object_name=re.compile(r\"^index$_join$\")\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存在视图访问",
        "solution": [
            "视图不能展开,复杂视图拆解、改写"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_LOOP_NUM",
        "desc": "嵌套层次过深",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "loop_num",
                "desc": "表嵌套的层次",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 3
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\nfrom rule import const\nfrom oracle_cmdb.ticket.sql_plan import OracleTicketSQLPlan\nfrom oracle_cmdb.capture import OracleSQLPlan\n\n\ndef code(rule, entries, **kwargs):\n\n    nested_loop = {\n        \"$or\": [\n            {\"operation\": re.compile(r\"NESTED LOOP\")},\n            {\"operation\": re.compile(r\"FILTER\")}\n        ]\n    }\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        statement_id: str = kwargs[\"statement_id\"]\n        ret = OracleTicketSQLPlan.objects.aggregate(\n            {\n                \"$match\": {\n                    \"statement_id\": statement_id,\n                    **nested_loop\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": {\n                        \"statement_id\": \"$statement_id\",\n                        \"plan_id\": \"$plan_id\",\n                        \"object_name\": \"$object_name\",\n                        \"object_type\": \"$object_type\",\n                    },\n                    \"count\": {\"$sum\": 1}\n                }\n            }\n        )\n        for d in ret:\n            if d[\"count\"] >= rule.gip(\"loop_num\"):\n                yield {\n                    \"object_name\": d[\"_id\"][\"object_name\"],\n                    \"object_type\": d[\"_id\"][\"object_type\"]\n                }\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        schema_name: str = kwargs[\"schema_name\"]\n        task_record_id: int = kwargs[\"task_record_id\"]\n\n        ret = OracleSQLPlan.objects.aggregate(\n            {\n                \"$match\": {\n                    \"task_record_id\": task_record_id,\n                    \"schema_name\": schema_name,\n                    **nested_loop\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": {\n                        \"sql_id\": \"$sql_id\",\n                        \"plan_hash_value\": \"$plan_hash_value\",\n                        \"object_name\": \"$object_name\",\n                        \"object_type\": \"$object_type\",\n                    },\n                    \"count\": {\"$sum\": 1}\n                }\n            }\n        )\n        for d in ret:\n            if d[\"count\"] >= rule.gip(\"loop_num\"):\n                yield {\n                    \"count\": d[\"count\"],\n                    **d[\"_id\"]\n                }\n\n\ncode_hole.append(code)\n\n\n",
        "status": true,
        "summary": "嵌套层次过深",
        "solution": [
            "改写sql逻辑减少表关联的数量"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_TAB_REL_NUM",
        "desc": "过多的表关联",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "tab_num",
                "desc": "关联表的数量",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 5
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "tab_num",
                "desc": "关联表的数量",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from oracle_cmdb.capture import OracleSQLPlan\n\n\ndef code(rule, entries, **kwargs):\n    task_record_id: int = kwargs[\"task_record_id\"]\n    schema_name: str = kwargs[\"schema_name\"]\n\n    ret = OracleSQLPlan.objects.aggregate(\n        {\n            \"$match\": {\n                \"task_record_id\": task_record_id,\n                \"schema_name\": schema_name,\n                \"object_type\": \"TABLE\"\n            }\n        },\n        {\n            \"$group\": {\n                \"_id\": {\n                    \"sql_id\": \"$sql_id\",\n                    \"plan_hash_value\": \"$plan_hash_value\",\n                    \"object_type\": \"$object_type\"\n                },\n                \"count\": {\"$sum\": 1}\n            }\n        }\n    )\n    for d in ret:\n        if d[\"count\"] >= rule.gip(\"tab_num\"):\n            yield {\n                \"sql_id\": d[\"_id\"][\"sql_id\"],\n                \"plan_hash_value\": d[\"_id\"][\"plan_hash_value\"],\n                \"tab_num\": d[\"count\"]\n            }\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "过多的表关联,影响性能",
        "solution": [
            "建议减少表关联,业务逻辑sql改写"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TABLE_ACCESS_BY_GLOBAL_INDEX",
        "desc": "全局索引扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\nfrom rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"TABLE ACCESS\",\n        options=re.compile(r\"BY GLOBAL INDEX ROWID\", re.I)\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            "合理设计分区索引"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SEQ_CACHESIZE",
        "desc": "序列CACHESIZE过小",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_SEQUENCE"
        ],
        "input_params": [
            {
                "name": "cache_size",
                "desc": "缓存大小",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 2000
            }
        ],
        "output_params": [
            {
                "name": "sequence_name",
                "desc": "序列名称",
                "unit": null,
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "cache_size",
                "desc": "缓存大小",
                "unit": null,
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select SEQUENCE_NAME, CACHE_SIZE \n            from dba_sequences \n            WHERE SEQUENCE_OWNER = '{schema_name}'\n                  AND CACHE_SIZE < {rule.gip('cache_size')}\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "cache值较小，内存中预先缓存的cache值很快被耗尽，再次取值时需要修改数据字典信息，在此期间，会持有SQ锁",
        "solution": [
            "调整序列的cache值为2000以上"
        ],
        "weight": 1.0,
        "max_score": 3,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SINGLETABLE_INDEX_NUM",
        "desc": "索引数量过多",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_INDEX"
        ],
        "input_params": [
            {
                "name": "index_num",
                "desc": "索引个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 7
            }
        ],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": null
            },
            {
                "name": "index_num",
                "desc": "索引数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": null
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    SELECT T.TABLE_NAME table_name, COUNT(1) index_num FROM DBA_INDEXES T\n           WHERE T.OWNER = '{schema_name}'\n           GROUP BY T.TABLE_NAME \n           HAVING COUNT(1) > {rule.gip(\"index_num\")} ORDER BY COUNT(1) DESC\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "索引可以提高访问速度,但数量过多将导致空间消耗过大,且索引维护成本较高,影响DML效率等问题。应控制索引数量。",
        "solution": [
            "构建战略性索引结构,不要针对每个需求都通过创建索引解决"
        ],
        "weight": 12.0,
        "max_score": 9,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "LONG_COLUMN_TAB",
        "desc": "记录长度定义过长",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT"
        ],
        "input_params": [
            {
                "name": "data_len_ratio",
                "desc": "记录定义长度与实际存储长度占比",
                "unit": "",
                "data_type": "FLOAT",
                "_cls": "RuleInputParams",
                "value": 0.5
            }
        ],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "col_sum",
                "desc": "行记录定义字节数",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "avg_row_len",
                "desc": "记录实际平均存放字节数",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "column_names",
                "desc": "超过长度的字段名",
                "unit": "",
                "data_type": "LIST",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = \"\"\"\n    SELECT CASE userenv('language')\n               WHEN 'SIMPLIFIED CHINESE_CHINA.AL32UTF8' THEN 3\n               WHEN 'AMERICAN_AMERICA.AL32UTF8' THEN 3\n               WHEN 'SIMPLIFIED CHINESE_CHINA.ZHS16GBK' THEN 4\n               WHEN 'AMERICAN_AMERICA.ZHS16GBK' THEN 4\n               WHEN 'SIMPLIFIED CHINESE_CHINA.UTF8' THEN 3\n           END\n    FROM dual\n    \"\"\"\n    v_len = cmdb_connector.select(sql)\n    sql = f\"\"\"\n    SELECT t.table_name,\n           a.col_sum,\n           t.avg_row_len\n    FROM dba_tables t,\n\n      (SELECT TABLE_NAME,\n              sum(LENGTH) col_sum\n       FROM\n         (SELECT TABLE_NAME,\n                 data_length,\n                 COLUMN_NAME,\n                 sum(CASE data_type\n                         WHEN 'VARCHAR2' THEN round(data_length / 1, 2)\n                         WHEN 'VARCHAR' THEN round(data_length / 1, 2)\n                         ELSE data_length\n                     END) LENGTH\n          FROM dba_tab_cols\n          WHERE OWNER='{schema_name}'\n          GROUP BY TABLE_NAME,\n                   data_length,\n                   COLUMN_NAME) t\n       GROUP BY TABLE_NAME) a\n    WHERE t.owner='{schema_name}'\n      AND t.table_name = a.table_name\n      AND t.avg_row_len / a.col_sum < {rule.gip('data_len_ratio')}\n    \"\"\"\n    records = cmdb_connector.select_dict(sql)\n\n    # 新增功能，返回超过实际长度的字段名\n    sql = f\"\"\"\n                select table_name, column_name, data_length \n                from dba_tab_cols t\n                where t.owner = '{schema_name}'\n    \"\"\"\n    table_columns = cmdb_connector.select(sql)\n    for record in records:\n        record[\"column_names\"] = set()\n        for the_table_name, the_column_name, the_data_length in table_columns:\n            if record[\"table_name\"] == the_table_name:\n                if the_data_length >= record[\"avg_row_len\"]:\n                    record[\"column_names\"].add(the_column_name)\n        record[\"column_names\"] = list(record[\"column_names\"])\n        yield record\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "记录定义长度与实际存储长度差异过大,请考虑字段类型定义是否合理,个别字段过长是否可分表存储。",
        "solution": [
            "按需定义字段长度"
        ],
        "weight": 0.5,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TIMESTAMP",
        "desc": "不包含时间戳字段的表",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select table_name \n        from dba_tables \n        where owner = '{schema_name}' \n            and table_name not in (\n                select table_name \n                    from dba_tab_cols \n                    where owner = '{schema_name}' and (\n                            column_name like 'CREATE%' or column_name like 'UPDATE%'\n                        ) and data_type = 'DATE')\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "时间戳是获取增量数据的一种方法。建议在表内增加创建时间、更新时间的时间戳字段。命名方式为CREATE_TIME、UPDATE_TIME",
        "solution": [
            "添加时间字段(比如插入、更新的时间戳)"
        ],
        "weight": 1.0,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "USE_PROCEDURE",
        "desc": "存在存储过程",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "proc_name",
                "desc": "存储过程名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "object_type",
                "desc": "类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select object_name as proc_name, object_type \n        from dba_objects \n        where object_type = 'PROCEDURE' and owner = '{schema_name}'\n        order by object_type\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存储过程将影响数据库的异构迁移能力,并存在代码维护性较差等原因",
        "solution": [
            "用应用端程序实现将存储过程"
        ],
        "weight": 1.0,
        "max_score": 9,
        "level": 2,
        "db_model": "OLTP"
    }
]
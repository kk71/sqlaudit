[
    {
        "name": "TOOMANY_IN_LIST",
        "desc": "IN List元素过多",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [
            {
                "name": "in_list_num",
                "desc": "inlist元素个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 20
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs[\"single_sql\"]\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    sql_content = [\n        x\n        for x in re.findall(r\"\\s+in\\s+\\((.*?)\\)\", sql_text, re.I+re.S)\n        if 'select' not in x.lower()\n    ]\n    for value in sql_content:\n        if value.count(\",\") >= rule.gip(\"in_list_num\") - 1:\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "IN List元素过多",
        "solution": [
            "改用临时表存入变量"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "DML_DDL_MIXED",
        "desc": "DML和DDL语句混写",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "DML",
            "DDL"
        ],
        "input_params": [],
        "output_params": [],
        "code": "from parsed_sql import const\n\n\ndef code(rule, entries, **kwargs):\n    sqls: [dict] = kwargs.get(\"sqls\")\n\n    sql_types: set = {i[\"sql_type\"] for i in sqls}\n    if const.SQL_DDL in sql_types and const.SQL_DML in sql_types:\n        yield {}\n\n\ncode_hole.append(code)\n",
        "status": false,
        "summary": "DML、DDL语句混写会导致上线失败回滚时，DDL无法回滚",
        "solution": [
            "建议拆分DDL和DML语句"
        ],
        "weight": 0.1,
        "max_score": 5,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "BAD_JOIN",
        "desc": "存在全连接或外连接",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    cross_outer_join = re.compile(r\"(cross join)|(outer join)\", re.M+re.I)\n\n    if cross_outer_join.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存在全连接或外连接,cross join或outer join情况",
        "solution": [
            "改写为inner join"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_ADD_COLUMN",
        "desc": "添加字段无默认值",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'alter\\s+table\\s+.+\\s+add', sql_text, re.I+re.M):\n        if not re.search(r\".+\\s+default\\s+.+\", sql_text, re.I+re.M):\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            "尽可能在添加字段的时候指定默认值"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_BITMAP_INDEX",
        "desc": "位图索引",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\nfrom cmdb.const import MODEL_OLTP\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    cmdb = kwargs.get(\"cmdb\")\n    db_model = cmdb.db_model\n\n    if db_model == MODEL_OLTP and\\\n            re.search(r\"create\\s+bitmap\\s+index\", sql_text, re.I+re.M):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_COLUMN_NUMBER",
        "desc": "表字段数",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    \"\"\"列数\"\"\"\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if not re.search(r\"create\\s+table\", sql_text, re.I+re.M):\n        return\n\n    left_brackets = 0\n    left_flag = 0\n    right_flag = 0\n    for index, s in enumerate(sql_text):\n        if s == \"(\":\n            left_brackets += 1\n            if left_brackets == 1:\n                left_flag = index\n        elif s == \")\":\n            left_brackets -= 1\n            if left_brackets == 0:\n                right_flag = index\n                break\n\n    sql = sql_text[left_flag + 1: right_flag]\n\n    if len(sql.split(',')) > 255:  # TODO,这不应写死\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_CONCURRENCY_LEVEL",
        "desc": "并行度",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if not re.search(r\"create\\s+table\", sql_text, re.I+re.M):\n        return\n\n    if 'parallel' not in sql_text.lower():\n        return\n    parallel = re.search(r\"parallel\\s+(\\d)\", sql_text, re.I+re.M)\n    if parallel and int(parallel.group(1)) > 1:\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_CREATE_TABLE_NOT_DEFINE_TABLE_SPACE",
        "desc": "创建表未指定表空间",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'create\\s+table', sql_text, re.I+re.M) and\\\n            'tablespace' not in sql_text.lower():\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_DB_LINK_CREATED",
        "desc": "创建数据库链接",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'create\\s+database\\s+link', sql_text, re.I+re.M):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_DB_LINK_OFFLINE",
        "desc": "存在DBLINK",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search('@', sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_DELETE",
        "desc": "存在delete语句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    for token in this_one_sql.tokens:\n        if token.normalized == \"DELETE\":\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n            return\n\n\ncode_hole.append(code)\n\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_DROP",
        "desc": "存在drop语句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    for token in this_one_sql.tokens:\n        if token.normalized == \"DROP\":\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n            return\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_INDEX_NOT_DEFINE_TABLE_SPACE",
        "desc": "索引未定义表空间",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'create\\s+index', sql_text, re.I+re.M) and\\\n            'tablespace' not in sql_text.lower():\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_INDEX_ONLINE",
        "desc": "创建索引时未带上online关键字",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'create\\s+index\\s+', sql_text, re.I+re.M):\n        if not re.search(r\"\\s+online\", sql_text, re.I+re.M):\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "创建索引的时候加上online,否则索引创建期间会锁表",
        "solution": [
            "创建索引的时候加上online"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_LOB_USING",
        "desc": "LOB使用",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if (\n            not re.search(r\"create\\s+table\", sql_text, re.I)\n            and not re.search(r\"alter\\s+table\", sql_text, re.I)\n    ) or any([\n        x in sql_text.lower()\n        for x in ['blob', 'clob', 'bfile', 'xmltype']\n    ]):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_MODIFY_COLUMN",
        "desc": "修改字段类型",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'alter\\s+table\\s+.+\\s+modify', sql_text, re.I+re.M):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_SEQUENCE",
        "desc": "序列",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if not re.search(r\"create\\s+sequence\", sql_text, re.I+re.M):\n        return\n\n    res = re.search(r\"cache\\s+(\\d+)\", sql_text, re.I)\n    if 'order' in sql_text.lower() or\\\n            'cache' not in sql_text.lower() or\\\n            (res and int(res.group(1)) < 2000):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_TRUNCATE",
        "desc": "存在truncate语句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    for token in this_one_sql.tokens:\n        if token.normalized == \"TRUNCATE\":\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n            return\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "CHECK_USING_REVOKE",
        "desc": "撤回权限",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DDL",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if re.search(r'revoke\\s+', sql_text, re.I+re.M):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "DML_ALLDATA",
        "desc": "delete或update中缺少where条件",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    pat = re.compile(r'(\\s)?((update )|(delete ))', re.M+re.I)\n    pat1 = re.compile(r'\\s+where\\s+', re.S+re.I)\n\n    if pat.search(sql_text) and not pat1.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "DML_SORT",
        "desc": "delete或update中出现order by子句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    dml_sort = re.compile(r\"(\\s)?((update )|(delete )).*order by\", re.M+re.I)\n\n    if dml_sort.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            ""
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "LIKE_UNINDEX",
        "desc": "谓词条件使用like %xxx,无法使用索引",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    like_unindex = re.compile(r\"like\\s+\\.?%\", re.M+re.I)\n\n    if like_unindex.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "谓词条件使用like %xxx,无法使用索引",
        "solution": [
            "从业务角度出发,分析是否可使用精确运算符或类似like'xx%'"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "LONG_TEXT",
        "desc": "SQL文本过长",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [
            {
                "name": "char_num",
                "desc": "SQL字符数量",
                "unit": "个",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 5000
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "def code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text\"]\n\n    length = len(sql_text)\n    if length >= rule.gip(\"char_num\"):\n        yield {\n            \"char_num\": length,\n            \"sql_id\": kwargs.get(\"sql_id\", None)\n        }\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "SQL文本过长",
        "solution": [
            "sql改写为精简语句"
        ],
        "weight": 0.0,
        "max_score": 0,
        "level": 1,
        "db_model": "OLTP"
    },
    {
        "name": "SELECT_ANY",
        "desc": "使用select *",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    select_any = re.compile(\"(select \\\\*)|(select .*\\\\.\\\\*)\")\n\n    if re.search(select_any, sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "禁止使用select *,必须明确选择所需的列",
        "solution": [
            "使用明确的列"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_FROM",
        "desc": "from段出现子查询",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    has_from = False\n    for token in this_one_sql.tokens:\n        if token.normalized == \"FROM\":\n            has_from = True\n            continue\n        if has_from:\n            if recursively_find_following_select(token):\n                yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "from段出现子查询",
        "solution": [
            "改写为表关联"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_HAVING",
        "desc": "having段出现子查询",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    has_from = False\n    for token in this_one_sql.tokens:\n        if token.normalized == \"HAVING\":\n            has_from = True\n            continue\n        if has_from:\n            if recursively_find_following_select(token):\n                yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "having段出现子查询",
        "solution": [
            "改写为表关联"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_REP",
        "desc": "重复查询子句",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "def code(rule, entries, **kwargs):\n    \"\"\"重复查询子句\"\"\"\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    str_len = len(sql_text)\n    left_bracket = []\n    sql_content = []\n    subquery = []\n\n    for i in range(str_len):\n        if sql_text[i] == \"(\":\n            left_bracket.append(i)\n        if sql_text[i] == \")\":\n            start = sum(left_bracket[-1:-2:-1]) + 1\n            stop = i - 1\n            sql_content.append(sql_text[start:stop])\n    for value in sql_content:\n        if \"select\" in value.lower() and value not in subquery:\n            subquery.append(value)\n        elif \"select\" in value.lower() and value in subquery:\n            yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "禁止使用重复的查询子句,应使用with as替换子句(仅限Oracle)来提升SQL执行效率",
        "solution": [
            "1.withas",
            "2.改写sql避免重复查询"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_SELECT",
        "desc": "select段出现子查询",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    has_from = False\n    for token in this_one_sql.tokens:\n        if token.normalized == \"SELECT\":\n            has_from = True\n            continue\n        if has_from:\n            if recursively_find_following_select(token):\n                yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "select段出现子查询",
        "solution": [
            "改写为表关联"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SUBQUERY_WHERE",
        "desc": "where段出现子查询",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "from parsed_sql.parsed_sql import ParsedSQL\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n    ps = ParsedSQL(sql_text)\n    this_one_sql = ps[0]\n    has_from = False\n    for token in this_one_sql.tokens:\n        if token.normalized == \"WHERE\":\n            has_from = True\n            continue\n        if has_from:\n            if recursively_find_following_select(token):\n                yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "where段出现子查询",
        "solution": [
            "改写为表关联"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "TOOMANY_BIND",
        "desc": "绑定变量过多",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "DML",
            "DDL",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [
            {
                "name": "num_of_bound_var",
                "desc": "绑定变量个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 50
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "def code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if sql_text.count(\":\") >= rule.gip(\"num_of_bound_var\"):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "绑定变量过多",
        "solution": [
            "减少绑定变量"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TOOMANY_OR",
        "desc": "多个过滤条件通过or连接",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [
            {
                "name": "or_num",
                "desc": "or个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 5
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    if len(re.compile(r\"\\s+or\\s+\", re.I+re.M).findall(sql_text))\\\n            >= rule.gip(\"or_num\"):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "多个过滤条件通过or连接,防止优化器出现选择异常",
        "solution": [
            "改用临时表存入变量"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "UNION",
        "desc": "出现union",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    pat = re.compile(r\"\\s+union\\s+\", re.I+re.M)\n\n    if pat.findall(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "出现union,防止出现不必要的排序动作",
        "solution": [
            "改写union和sql逻辑中去重"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "WHERE_FUNC",
        "desc": "查询列上使用表达式",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    where_func = re.compile(r\"where\\s+.*?[+\\-*/()].*[<>=]{1,2}?\", re.I+re.S)\n\n    if where_func.search(sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "禁止在where语句的比较符左侧使用运算表达式，或者函数表达式",
        "solution": [
            "1.运算、函数写在表达式右边",
            "2.应用程序实现函数功能"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "WHERE_NOT",
        "desc": "谓词中存在负向操作符!=等",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_STATIC",
            "DML",
            "TICKET_STATIC_CMDB_INDEPENDENT",
            "ONLINE",
            "SQL",
            "SQL_TEXT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "import re\n\n\ndef code(rule, entries, **kwargs):\n    single_sql: dict = kwargs.get(\"single_sql\")\n    sql_text: str = single_sql[\"sql_text_no_comment\"]\n\n    where_not = re.compile(\"(!=)|(<>)|(!>)|(!<)\")\n\n    if re.search(where_not, sql_text):\n        yield {\"sql_id\": kwargs.get(\"sql_id\", None)}\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "谓词中存在负向操作符,!=,<>,!<,!>,not exists,not",
        "solution": [
            "1.如果列值是连续,可把否定操作,更改为两个区间",
            "2.不建议使用不等值运算"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_INDEX_FAST_FULL_SCAN",
        "desc": "执行计划中索引快速全扫",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "ind_phy_size",
                "desc": "索引物理大小",
                "unit": "MB",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 100
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"INDEX\",\n        options=\"FAST FULL SCAN\"\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "大索引快速全扫描",
        "solution": [
            "SQL逻辑能否改写获取更少的数据"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_INDEX_FULL_SCAN",
        "desc": "执行计划中索引全扫",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "ind_phy_size",
                "desc": "索引物理大小",
                "unit": "MB",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 1024.0
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "object_name",
                "desc": "对象名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(operation=\"INDEX\", options=\"FULL SCAN\")\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "大索引全扫描",
        "solution": [
            "SQL逻辑能否改写获取更少的数据"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_INDEX_SKIP_SCAN",
        "desc": "执行计划中存在索引跳描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(operation=\"INDEX\", options=\"SKIP SCAN\")\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "索引跳跃扫描",
        "solution": [
            "索引列的先后顺序是否合理"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_MERGE_JOIN_CARTESIAN",
        "desc": "笛卡尔积关联",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"MERGE JOIN\",\n        options=\"CARTESIAN\"\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "笛卡尔积",
        "solution": [
            "1.表关联条件缺失,加上关联条件",
            "2.统计信息不准确,手工收集统计信息"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_PARALLEL_FETCH",
        "desc": "存在并行访问特征",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(operation=\"PX COORDINATOR\")\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存在并行访问特征",
        "solution": [
            "取消表、索引、sql中的并行设置"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_PARTITION_RANGE_ALL",
        "desc": "分区全扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"PARTITION RANGE\",\n        options=\"ALL\"\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "分区全扫描",
        "solution": [
            "分区键设计是否合理"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_PARTITION_RANGE_INLIST_OR",
        "desc": "非连续分区扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"PARTITION RANGE\",\n        options__in=(\"INLIST\", \"OR\")\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "非连续分区扫描",
        "solution": [
            "分区键设计是否合理"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_PARTITION_RANGE_ITERATOR",
        "desc": "跨分区扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"PARTITION RANGE\",\n        options=\"ITERATOR\"\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_type\", \"object_name\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "跨分区扫描",
        "solution": [
            "分区键设计是否合理"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_TABLE_FULL_SCAN",
        "desc": "全表扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "table_phy_size",
                "desc": "表物理大小",
                "unit": "MB",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 2048
            },
            {
                "name": "table_row_num",
                "desc": "表行数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 100000
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from oracle_cmdb.capture.obj_tab_info import OracleObjTabInfo\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"TABLE ACCESS\",\n        options=\"FULL\",\n        object_type=\"TABLE\"\n    )\n\n    for d in values_dict(qs,\n                         \"sql_id\",\n                         \"plan_hash_value\",\n                         \"object_name\",\n                         \"object_type\",\n                         \"task_record_id\",\n                         \"schema_name\"):\n        the_table = OracleObjTabInfo.objects(\n            task_record_id=d[\"task_record_id\"],\n            schema_name=d[\"schema_name\"],\n            table_name=d[\"object_name\"]\n        ).first()\n        if not the_table:\n            continue\n        if the_table.num_rows >= rule.gip(\"table_row_num\") or\\\n                the_table.phy_size_mb >= rule.gip(\"table_phy_size\"):\n            yield {\n                k: v\n                for k, v in d.items()\n                if k in (\"sql_id\", \"plan_hash_value\", \"object_name\", \"object_type\")\n            }\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "全表扫描",
        "solution": [
            "1.缺索引评估创建索引",
            "2.取max、min值评估创建索引",
            "3.索引失效重建索引,分区表维护记得维护索引",
            "4.对条件字段使用函数或表达式a.函数、表达式放到等于号的右边b.创建函数索引(下策)",
            "5.出现隐式转换a.不同类型的谓词匹配先显式转换b.表定义根据数据选择正确的数据类型",
            "6.使用isNULL做查询条件a.不建议使用null值b.null值较少的情况可创建组合索引或者伪列索引(createindexidx_1ontab1(col1,0)c.将null定义一个普通变量",
            "7.使用不等运算符<>!=做查询条件a.尽量少用不等判断；b.如果列值是连续,可把否定操作更改为两个区间；c.如果列值不多,可用inlist枚举其他所有值",
            "8.'％a％''％a'建议精确匹配",
            "9.sql逻辑,比如最大值,改用窗口函数",
            "10.弱选择sql,返回结果集较大建议a.添加更多的谓词减少数据的访问,比如时间b.改造分区表c.使用覆盖索引",
            "11.hintfull禁用hint1",
            "12.统计信息不准确数据批量加载程序触发收集统计信息"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_TO_CHANGE_TYPE",
        "desc": "隐式转换",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\nfrom rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        filter_predicates=re.compile(\n            r\"(SYS_OP|TO_NUMBER|INTERNAL_FUNCTION)\", re.I)\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "隐式转换",
        "solution": [
            "1.显式转换",
            "2.选择合适的字段类型"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_VIEW_SCAN",
        "desc": "存在视图访问",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\nfrom rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        object_type=\"VIEW\",\n        object_owner__ne=None,\n        object_name=re.compile(r\"^index$_join$\")\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存在视图访问",
        "solution": [
            "视图不能展开,复杂视图拆解、改写"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_LOOP_NUM",
        "desc": "嵌套层次过深",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "loop_num",
                "desc": "表嵌套的层次",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 3
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\nfrom rule import const\nfrom oracle_cmdb.ticket.sql_plan import OracleTicketSQLPlan\nfrom oracle_cmdb.capture import OracleSQLPlan\n\n\ndef code(rule, entries, **kwargs):\n\n    nested_loop = {\n        \"$or\": [\n            {\"operation\": re.compile(r\"NESTED LOOP\")},\n            {\"operation\": re.compile(r\"FILTER\")}\n        ]\n    }\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        statement_id: str = kwargs[\"statement_id\"]\n        ret = OracleTicketSQLPlan.objects.aggregate(\n            {\n                \"$match\": {\n                    \"statement_id\": statement_id,\n                    **nested_loop\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": {\n                        \"statement_id\": \"$statement_id\",\n                        \"plan_id\": \"$plan_id\",\n                        \"object_name\": \"$object_name\",\n                        \"object_type\": \"$object_type\",\n                    },\n                    \"count\": {\"$sum\": 1}\n                }\n            }\n        )\n        for d in ret:\n            if d[\"count\"] >= rule.gip(\"loop_num\"):\n                yield {\n                    \"object_name\": d[\"_id\"][\"object_name\"],\n                    \"object_type\": d[\"_id\"][\"object_type\"]\n                }\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN in entries:\n        schema_name: str = kwargs[\"schema_name\"]\n        task_record_id: int = kwargs[\"task_record_id\"]\n\n        ret = OracleSQLPlan.objects.aggregate(\n            {\n                \"$match\": {\n                    \"task_record_id\": task_record_id,\n                    \"schema_name\": schema_name,\n                    **nested_loop\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": {\n                        \"sql_id\": \"$sql_id\",\n                        \"plan_hash_value\": \"$plan_hash_value\",\n                        \"object_name\": \"$object_name\",\n                        \"object_type\": \"$object_type\",\n                    },\n                    \"count\": {\"$sum\": 1}\n                }\n            }\n        )\n        for d in ret:\n            if d[\"count\"] >= rule.gip(\"loop_num\"):\n                yield {\n                    \"count\": d[\"count\"],\n                    **d[\"_id\"]\n                }\n\n\ncode_hole.append(code)\n\n\n",
        "status": true,
        "summary": "嵌套层次过深",
        "solution": [
            "改写sql逻辑减少表关联的数量"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_TAB_REL_NUM",
        "desc": "过多的表关联",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [
            {
                "name": "tab_num",
                "desc": "关联表的数量",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 5
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "tab_num",
                "desc": "关联表的数量",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "from oracle_cmdb.capture import OracleSQLPlan\n\n\ndef code(rule, entries, **kwargs):\n    task_record_id: int = kwargs[\"task_record_id\"]\n    schema_name: str = kwargs[\"schema_name\"]\n\n    ret = OracleSQLPlan.objects.aggregate(\n        {\n            \"$match\": {\n                \"task_record_id\": task_record_id,\n                \"schema_name\": schema_name,\n                \"object_type\": \"TABLE\"\n            }\n        },\n        {\n            \"$group\": {\n                \"_id\": {\n                    \"sql_id\": \"$sql_id\",\n                    \"plan_hash_value\": \"$plan_hash_value\",\n                    \"object_type\": \"$object_type\"\n                },\n                \"count\": {\"$sum\": 1}\n            }\n        }\n    )\n    for d in ret:\n        if d[\"count\"] >= rule.gip(\"tab_num\"):\n            yield {\n                \"sql_id\": d[\"_id\"][\"sql_id\"],\n                \"plan_hash_value\": d[\"_id\"][\"plan_hash_value\"],\n                \"tab_num\": d[\"count\"]\n            }\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "过多的表关联,影响性能",
        "solution": [
            "建议减少表关联,业务逻辑sql改写"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TABLE_ACCESS_BY_GLOBAL_INDEX",
        "desc": "全局索引扫描",
        "db_type": "oracle",
        "entries": [
            "TICKET",
            "TICKET_DYNAMIC",
            "DML",
            "ONLINE",
            "SQL",
            "SQL_PLAN"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "import re\n\nfrom rule import const\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_plan_qs = kwargs[\"sql_plan_qs\"]\n\n    qs = sql_plan_qs.filter(\n        operation=\"TABLE ACCESS\",\n        options=re.compile(r\"BY GLOBAL INDEX ROWID\", re.I)\n    )\n\n    if const.RULE_ENTRY_TICKET_DYNAMIC in entries:\n        for d in values_dict(qs, \"object_name\", \"object_type\"):\n            yield d\n\n    elif const.RULE_ENTRY_ONLINE_SQL_PLAN:\n        for d in values_dict(qs,\n                             \"sql_id\",\n                             \"plan_hash_value\",\n                             \"object_name\",\n                             \"object_type\"):\n            yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "",
        "solution": [
            "合理设计分区索引"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 3,
        "db_model": "OLTP"
    },
    {
        "name": "SEQ_CACHESIZE",
        "desc": "序列CACHESIZE过小",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_SEQUENCE"
        ],
        "input_params": [
            {
                "name": "cache_size",
                "desc": "缓存大小",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 2000
            }
        ],
        "output_params": [
            {
                "name": "sequence_name",
                "desc": "序列名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "cache_size",
                "desc": "缓存大小",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select SEQUENCE_NAME, CACHE_SIZE \n            from dba_sequences \n            WHERE SEQUENCE_OWNER = '{schema_name}'\n                  AND CACHE_SIZE < {rule.gip('cache_size')}\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "cache值较小，内存中预先缓存的cache值很快被耗尽，再次取值时需要修改数据字典信息，在此期间，会持有SQ锁",
        "solution": [
            "调整序列的cache值为2000以上"
        ],
        "weight": 1.0,
        "max_score": 3,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SINGLETABLE_INDEX_NUM",
        "desc": "索引数量过多",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_INDEX"
        ],
        "input_params": [
            {
                "name": "index_num",
                "desc": "索引个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 7
            }
        ],
        "output_params": [
            {
                "name": "table_owner",
                "desc": "表用户",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "index_num",
                "desc": "索引数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    SELECT T.OWNER table_owner, T.TABLE_NAME table_name, COUNT(1) index_num\n            FROM DBA_INDEXES T\n            WHERE T.OWNER = '{schema_name}'\n            GROUP BY T.OWNER, T.TABLE_NAME \n            HAVING COUNT(1) > {rule.gip(\"index_num\")} \n            ORDER BY COUNT(1) DESC\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "索引可以提高访问速度,但数量过多将导致空间消耗过大,且索引维护成本较高,影响DML效率等问题。应控制索引数量。",
        "solution": [
            "构建战略性索引结构,不要针对每个需求都通过创建索引解决"
        ],
        "weight": 12.0,
        "max_score": 9,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "LONG_COLUMN_TAB",
        "desc": "记录长度定义过长",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT"
        ],
        "input_params": [
            {
                "name": "data_len_ratio",
                "desc": "记录定义长度与实际存储长度占比",
                "unit": "",
                "data_type": "FLOAT",
                "_cls": "RuleInputParams",
                "value": 0.5
            }
        ],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "col_sum",
                "desc": "行记录定义字节数",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "avg_row_len",
                "desc": "记录实际平均存放字节数",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "column_names",
                "desc": "超过长度的字段名",
                "unit": "",
                "data_type": "LIST",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = \"\"\"\n    SELECT CASE userenv('language')\n               WHEN 'SIMPLIFIED CHINESE_CHINA.AL32UTF8' THEN 3\n               WHEN 'AMERICAN_AMERICA.AL32UTF8' THEN 3\n               WHEN 'SIMPLIFIED CHINESE_CHINA.ZHS16GBK' THEN 4\n               WHEN 'AMERICAN_AMERICA.ZHS16GBK' THEN 4\n               WHEN 'SIMPLIFIED CHINESE_CHINA.UTF8' THEN 3\n           END\n    FROM dual\n    \"\"\"\n    v_len = cmdb_connector.select(sql)\n    sql = f\"\"\"\n    SELECT t.table_name,\n           a.col_sum,\n           t.avg_row_len\n    FROM dba_tables t,\n\n      (SELECT TABLE_NAME,\n              sum(LENGTH) col_sum\n       FROM\n         (SELECT TABLE_NAME,\n                 data_length,\n                 COLUMN_NAME,\n                 sum(CASE data_type\n                         WHEN 'VARCHAR2' THEN round(data_length / 1, 2)\n                         WHEN 'VARCHAR' THEN round(data_length / 1, 2)\n                         ELSE data_length\n                     END) LENGTH\n          FROM dba_tab_cols\n          WHERE OWNER='{schema_name}'\n          GROUP BY TABLE_NAME,\n                   data_length,\n                   COLUMN_NAME) t\n       GROUP BY TABLE_NAME) a\n    WHERE t.owner='{schema_name}'\n      AND t.table_name = a.table_name\n      AND t.avg_row_len / a.col_sum < {rule.gip('data_len_ratio')}\n    \"\"\"\n    records = cmdb_connector.select_dict(sql)\n\n    # 新增功能，返回超过实际长度的字段名\n    sql = f\"\"\"\n                select table_name, column_name, data_length \n                from dba_tab_cols t\n                where t.owner = '{schema_name}'\n    \"\"\"\n    table_columns = cmdb_connector.select(sql)\n    for record in records:\n        record[\"column_names\"] = set()\n        for the_table_name, the_column_name, the_data_length in table_columns:\n            if record[\"table_name\"] == the_table_name:\n                if the_data_length >= record[\"avg_row_len\"]:\n                    record[\"column_names\"].add(the_column_name)\n        record[\"column_names\"] = list(record[\"column_names\"])\n        yield record\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "记录定义长度与实际存储长度差异过大,请考虑字段类型定义是否合理,个别字段过长是否可分表存储。",
        "solution": [
            "按需定义字段长度"
        ],
        "weight": 0.5,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TIMESTAMP",
        "desc": "不包含时间戳字段的表",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select table_name \n        from dba_tables \n        where owner = '{schema_name}' \n            and table_name not in (\n                select table_name \n                    from dba_tab_cols \n                    where owner = '{schema_name}' and (\n                            column_name like 'CREATE%' or column_name like 'UPDATE%'\n                        ) and data_type = 'DATE')\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "时间戳是获取增量数据的一种方法。建议在表内增加创建时间、更新时间的时间戳字段。命名方式为CREATE_TIME、UPDATE_TIME",
        "solution": [
            "添加时间字段(比如插入、更新的时间戳)"
        ],
        "weight": 1.0,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "USE_PROCEDURE",
        "desc": "存在存储过程",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "proc_name",
                "desc": "存储过程名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "object_type",
                "desc": "类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select object_name as proc_name, object_type \n        from dba_objects \n        where object_type = 'PROCEDURE' and owner = '{schema_name}'\n        order by object_type\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存储过程将影响数据库的异构迁移能力,并存在代码维护性较差等原因",
        "solution": [
            "用应用端程序实现将存储过程"
        ],
        "weight": 1.0,
        "max_score": 9,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "USE_FUNCTION",
        "desc": "存在函数",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "func_name",
                "desc": "函数名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select object_name as func_name\n        from dba_objects \n        where object_type = 'FUNCTION' and owner = '{schema_name}' \n        order by object_type\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "函数将影响数据库的异构迁移能力,并存在代码维护性较差等原因",
        "solution": [
            "用应用端程序实现函数"
        ],
        "weight": 3.0,
        "max_score": 3,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "DUPLICATE_INDEX",
        "desc": "字段重复索引",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_INDEX"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "column_name",
                "desc": "字段名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "table_owner",
                "desc": "表用户",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "repeat_times",
                "desc": "重复次数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "referred_index_name",
                "desc": "涉及索引名",
                "unit": "",
                "data_type": "LIST",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\nfrom collections import defaultdict\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    SELECT T.TABLE_OWNER, \n            T.TABLE_NAME, \n            T.COLUMN_NAME, \n            COUNT(T.INDEX_NAME) repeat_times\n        FROM DBA_IND_COLUMNS T \n        WHERE T.INDEX_OWNER = '{schema_name}'\n        GROUP BY T.TABLE_OWNER, T.TABLE_NAME, T.COLUMN_NAME \n        HAVING COUNT(T.INDEX_NAME) > 1\n    \"\"\"\n    records = cmdb_connector.select_dict(sql)\n\n    # 获取字段重复索引的索引名\n    sql = f\"\"\"\n    select index_name, table_owner, table_name, column_name\n        from dba_ind_columns\n        WHERE INDEX_OWNER = '{schema_name}'\n    \"\"\"\n    index_records = cmdb_connector.select(sql)\n\n    # table_owner: table_name: column_name:: {index_name}\n    column_name_index_name_dict = \\\n        defaultdict(lambda: defaultdict(lambda: defaultdict(set)))\n    for index_name, table_owner, table_name, column_name in index_records:\n        column_name_index_name_dict[table_owner][table_name][column_name].add(index_name)\n    for record in records:\n        if record.get(\"referred_index_name\", None) is None:\n            record[\"referred_index_name\"]: list = []\n        index_names = column_name_index_name_dict[record[\"table_owner\"]][record[\"table_name\"]][record[\"column_name\"]]\n        record[\"referred_index_name\"].extend(index_names)\n        record[\"referred_index_name\"] = list(set(record[\"referred_index_name\"]))\n\n    yield from records\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "造成索引冗余，不仅占用空间，而且容易产生多个执行计划",
        "solution": [
            "监控索引，删除不必要的索引"
        ],
        "weight": 12.0,
        "max_score": 9,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "COUNT_SUBPART_TAB",
        "desc": "复合分区数量过多",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [
            {
                "name": "subpart_tab_num",
                "desc": "复合分区个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 200
            }
        ],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "partition_name",
                "desc": "分区名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "subpart_count",
                "desc": "子分区数量",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select t.table_name, t.partition_name, count(1) as subpart_count\n        from DBA_TAB_SUBPARTITIONS t  \n        where t.table_owner = '{schema_name}'\n        group by t.table_name, t.partition_name \n        having count(1) >= {rule.gip('subpart_tab_num')}\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "表的规模过大,将影响表的访问效率、增加维护成本等",
        "solution": [
            "1.建议重新分库，分表，分区",
            "2.历史数据归档"
        ],
        "weight": 0.5,
        "max_score": 3,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "COUNT_SUMPART_SINGLE_TAB",
        "desc": "分区数量过多",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [
            {
                "name": "part_tab_num",
                "desc": "分区个数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 200
            }
        ],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "part_tab_num",
                "desc": "分区数量",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select t.table_name, count(1) as part_tab_num\n        from DBA_TAB_PARTITIONS t \n        where t.table_owner = '{schema_name}'\n        group by t.table_name \n        having count(1) >= {rule.gip('part_tab_num')}\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "表的规模过大,将影响表的访问效率、增加维护成本等",
        "solution": [
            "1.建议重新分库，分表，分区",
            "2.历史数据归档"
        ],
        "weight": 0.5,
        "max_score": 3,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "DBLINKS_NUM",
        "desc": "存在DBLINK",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "dblink_name",
                "desc": "dblink名字",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "username",
                "desc": "访问的用户",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "hostname",
                "desc": "访问的主机",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select db_link as dblink_name, username, host as hostname\n        from dba_db_links \n        where owner = '{schema_name}'\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "数据库之间会同步SCN",
        "solution": [
            "禁用dblink，在应用程序端连接多个数据库操作"
        ],
        "weight": 10.0,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "IDX_FUNC",
        "desc": "使用函数索引",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_INDEX"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "index_name",
                "desc": "索引名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "index_type",
                "desc": "索引类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "index_description",
                "desc": "索引描述",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select t.INDEX_NAME, \n            t.INDEX_TYPE, \n            t.TABLE_NAME, \n            s.COLUMN_EXPRESSION index_description\n        from dba_indexes t, dba_ind_expressions s \n        where t.index_name = s.index_name \n            and t.table_name = s.TABLE_NAME\n            and t.index_name not like 'BIN%'  \n            and t.owner = '{schema_name}'\n            and t.index_type like '%FUNCTION%' \n        order by t.table_name, t.index_name\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "若使用函数索引，则说明列上使用了表达式，应检查查询列是否使用了表达式",
        "solution": [
            "1.函数在表达式右侧实现",
            "2.应用程序替换数据库函数"
        ],
        "weight": 0.5,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "GLOBAL_PART_INDEX",
        "desc": "存在全局分区索引",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_INDEX"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "index_name",
                "desc": "索引名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    SELECT X.INDEX_NAME, X.TABLE_NAME \n        FROM DBA_INDEXES X, DBA_PART_TABLES Y \n        WHERE X.OWNER = Y.OWNER \n            AND X.TABLE_NAME = Y.TABLE_NAME  \n            AND X.PARTITIONED = 'NO' \n            and X.OWNER = '{schema_name}'\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "在对分区表进行维护时，全局分区索引冗余导致失效",
        "solution": [
            "根据业务场景，创建分区索引"
        ],
        "weight": 0.3,
        "max_score": 3,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TRIGGERS_NUM",
        "desc": "存在触发器",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "trigger_name",
                "desc": "触发器名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "trigger_type",
                "desc": "类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select trigger_name, 'TRIGGER' as trigger_type\n        from dba_triggers \n        where owner = '{schema_name}'\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "触发器将影响数据库的异构迁移能力，并存在代码维护性较差等原因",
        "solution": [
            "用应用端程序实现触发器"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "BIG_TABLE_COUNT",
        "desc": "大表数量过多",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [
            {
                "name": "tab_phy_size",
                "desc": "表大小",
                "unit": "MB",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 10240
            }
        ],
        "output_params": [
            {
                "name": "segment_name",
                "desc": "段名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "segment_type",
                "desc": "段类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "tab_space",
                "desc": "表大小",
                "unit": "MB",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    SELECT segment_name, segment_type, bytes / 1024 / 1024 tab_space\n        FROM dba_segments\n        WHERE segment_type IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')\n            AND owner = '{schema_name}'\n            AND segment_name NOT LIKE 'BIN%'\n            and bytes / 1024 / 1024 >= {rule.gip('tab_phy_size')}\n        ORDER BY 3 DESC\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "表的规模过大,将影响表的访问效率、增加维护成本等",
        "solution": [
            "1.建议分库,分表,分区",
            "2.历史数据归档"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "IDX_BITMAP",
        "desc": "是否使用位图索引",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_INDEX"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "index_name",
                "desc": "索引名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "index_type",
                "desc": "索引类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "idx_col_name",
                "desc": "索引列",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select t.INDEX_NAME, t.INDEX_TYPE, t.TABLE_NAME, s.column_name idx_col_name\n        from dba_indexes t, dba_ind_columns s \n        where t.owner = s.table_owner \n            and t.index_name = s.index_name \n            and t.index_name not like 'BIN%' \n            and t.owner = '{schema_name}'\n            and t.index_type = 'BITMAP' \n        order by t.table_name, t.index_name\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "在OLTP在线交易系统中，如果有位图索引，则在DML操作时会产生大量的行锁",
        "solution": [
            "OLTP在线交易系统禁用位图索引"
        ],
        "weight": 0.5,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TABLE_LOB",
        "desc": "包含有大字段类型的表",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "column_name",
                "desc": "字段名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select table_name, column_name \n        from dba_lobs \n        where owner='{schema_name}'\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "不仅占用更多空间，而且维护起来困难，比如导入导出慢",
        "solution": [
            "建议在数据库外部进行存储大字段"
        ],
        "weight": 0.3,
        "max_score": 3,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "IDX_CLUSTERING_FACTOR",
        "desc": "索引的聚簇因子",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_INDEX"
        ],
        "input_params": [
            {
                "name": "cluster_row_ratio",
                "desc": "聚簇因子与表记录数比率",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 70
            }
        ],
        "output_params": [
            {
                "name": "index_name",
                "desc": "索引名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "index_type",
                "desc": "索引类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "clustering_factor",
                "desc": "聚簇因子",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "row_num",
                "desc": "表记录数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "cluster_row_ratio",
                "desc": "比率",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select * from (\n        select a.owner, \n                a.index_name, \n                decode(\n                    INDEX_TYPE,'NORMAL','B-tree',decode(index_type,'BITMAP','BitMap',decode(INDEX_TYPE,'FUNCTION-BASED NORMAL','Func',decode(table_type,'IOT','IOT',decode(index_type, 'LOB', 'Lob'))))\n                ) as index_type,\n                a.clustering_factor,\n                a.table_name,\n                b.num_rows as row_num,\n                trunc((a.clustering_factor - a.leaf_blocks) /(a.num_rows - a.leaf_blocks + 1) * 100,2) cluster_row_ratio\n            from dba_ind_statistics a, dba_tables b, dba_indexes c \n            where a.table_name = b.table_name \n                and a.index_name = c.index_name \n                and a.num_rows > 200000 \n                and ((a.clustering_factor - a.leaf_blocks) / (a.num_rows - a.leaf_blocks + 1) > 0.7 or a.blevel > 4) \n                and a.index_name not like '%BIN$%' \n                and a.owner = '{schema_name}'\n            order by 1, 6) \n        where cluster_row_ratio > {rule.gip('cluster_row_ratio')}\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "索引的聚簇因子大，容易造成该索引用不上",
        "solution": [
            "表数据重新存储"
        ],
        "weight": 0.5,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TAB_EXISTS_FK",
        "desc": "表中存在外键约束",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "constraint_name",
                "desc": "约束名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "column_name",
                "desc": "列名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "rel_tab_name",
                "desc": "关联表",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "rel_con_name",
                "desc": "关联约束名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": true
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select c.table_name,  \n            c.constraint_name,  \n            t.column_name, \n            (select distinct a.table_name  \n                from dba_constraints a  \n                where a.constraint_name = c.r_constraint_name \n                    and a.owner = c.owner) rel_tab_name,\n            c.r_constraint_name rel_con_name\n        from dba_constraints c, dba_cons_columns t  \n        where t.owner = c.owner  \n            and t.constraint_name = c.constraint_name \n            and c.owner = '{schema_name}'   \n            and c.table_name not like 'BIN$%'  \n            and c.constraint_type = 'R'\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存在外键约束时，当对主表的记录进行update或delete时，为了校验从表上是否存在依赖该记录的数据",
        "solution": [
            "1.在应用端实现外键约束",
            "2.无法去除外键,必须添加外键索引"
        ],
        "weight": 0.5,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_BUFFER_GETS",
        "desc": "SQL消耗逻辑读过高",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "SQL",
            "SQL_STAT"
        ],
        "input_params": [
            {
                "name": "buffer_gets",
                "desc": "buffer gets",
                "unit": "bytes",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 1000
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "cpu_time_delta",
                "desc": "使用的cpu资源",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "execution_delta",
                "desc": "执行次数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "buffer_gets_delta",
                "desc": "使用buffer的资源",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "disk_reads_delta",
                "desc": "物理读情况",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "elapsed_time_delta",
                "desc": "解析的时间",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_stat_qs = kwargs[\"sql_stat_qs\"]\n\n    qs = sql_stat_qs.filter(per_buffer_gets__gte=rule.gip(\"buffer_gets\"))\n\n    for d in values_dict(qs,\n                         \"sql_id\",\n                         \"plan_hash_value\",\n                         \"cpu_time_delta\",\n                         \"execution_delta\",\n                         \"buffer_gets_delta\",\n                         \"disk_reads_delta\",\n                         \"elapsed_time_delta\"):\n        yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "sql执行 buffer get过大",
        "solution": [
            "1.对sql执行计划进行分析并进行优化",
            "2.SQL执行次数是否合理"
        ],
        "weight": 0.1,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "IDX_BLEVEL",
        "desc": "索引对象高度过高",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_INDEX"
        ],
        "input_params": [
            {
                "name": "idx_level",
                "desc": "索引高度",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 3
            }
        ],
        "output_params": [
            {
                "name": "index_name",
                "desc": "索引名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "index_type",
                "desc": "索引类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "index_blevel",
                "desc": "索引高度",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select index_name,\n            type as index_type,\n            idx_blevel as index_blevel, \n            table_name \n        from (\n            select \n                    distinct t.INDEX_NAME as INDEX_NAME,\n                    decode(INDEX_TYPE,'NORMAL','B-tree',decode(index_type,'BITMAP','BitMap',decode(INDEX_TYPE,'FUNCTION-BASED NORMAL','Func',decode(table_type,'IOT','IOT',decode(index_type,'LOB','Lob'))))) as type,\n                    t.TABLE_NAME,\n                    t.blevel as idx_blevel \n                from dba_indexes t\n                where t.index_name not like 'BIN%'  \n                    and t.owner = '{schema_name}'\n                    and t.blevel > {rule.gip('idx_level')}\n                order by t.table_name, t.index_name)\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "索引高度越高，在进行读取时会产生更多的逻辑读",
        "solution": [
            "索引高度越高，说明数据越大，需要重新分库，分表，分区或者 历史数据归档"
        ],
        "weight": 0.5,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_SUB_CURSOR_COUNT",
        "desc": "SQL子游标过多",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "SQL",
            "SQL_STAT"
        ],
        "input_params": [
            {
                "name": "cursor_num",
                "desc": "子游标的数量",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 30
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "version_count",
                "desc": "子游标数量",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n    snap_id_s, snap_id_e = kwargs[\"snap_ids\"]\n\n    sql = f\"\"\"\n        SELECT sql_id, plan_hash_value, version_count\n        FROM\n          (SELECT t.parsing_schema_name AS username,\n                  t.sql_id,\n                  t.plan_hash_value,\n                  t.version_count,\n                  row_number() over(partition BY t.sql_id\n                                    ORDER BY t.plan_hash_value DESC) rank\n           FROM dba_hist_sqlstat t\n           WHERE t.parsing_schema_name = '{schema_name}'\n             AND (t.snap_id BETWEEN '{snap_id_s}' AND '{snap_id_e}')) e\n        WHERE e.rank = 1 and e.version_count >= {rule.gip('cursor_num')}\n    \"\"\"\n    for d in cmdb_connector.select_dict(sql):\n        yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "子游标过多",
        "solution": [
            "参考 SQLs With Bind Variable Has Very High Version Count (Doc ID 258742.1)定位原因"
        ],
        "weight": 0.1,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TAB_PARALLEL_ON",
        "desc": "表对象开启并行访问",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "table_type",
                "desc": "表类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "parallel_count",
                "desc": "并行度",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select t.table_name, \n            decode(t.partitioned, 'YES', 'PART',  decode(t.temporary, 'Y', 'TEMP', decode (t.iot_type,'IOT','IOT','NORMAL'))) table_type,\n            t.degree parallel_count\n        from dba_tables t  \n        where t.table_name not like 'BIN%'  \n            and t.owner = '{schema_name}'\n            and to_number(replace(ltrim(t.degree),'DEFAULT',0))  > 1 \n        order by table_type, table_name\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "当表被并发访问时，会引起资源竞争",
        "solution": [
            "关闭表的并行度，默认为1"
        ],
        "weight": 0.5,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "BIG_TABLE",
        "desc": "超过指定规模且没有分区的表",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [
            {
                "name": "tab_phy_size",
                "desc": "表大小",
                "unit": "GB",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 10
            }
        ],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "tab_phy_size",
                "desc": "表大小",
                "unit": "GB",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select * \n        from (\n            select segment_name as table_name,\n                    round(sum(bytes) / 1024 / 1024 / 1024, 2) as tab_phy_size \n                from dba_segments \n                where segment_type = 'TABLE' \n                    and owner = '{schema_name}'\n                    and segment_name not like 'BIN$%'  \n                group by segment_name\n            ) a  \n        where tab_phy_size > {rule.gip('tab_phy_size')}\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "表的规模过大,将影响表的访问效率、增加维护成本等",
        "solution": [
            "1.建议分库,分表,分区",
            "2.历史数据归档"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TABLE_MIS_PK",
        "desc": "没有主键的表",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select a.table_name \n        from dba_tables a \n        where a.owner = '{schema_name}'\n            and a.table_name not like 'BIN$%' \n        minus select b.table_name \n            from dba_constraints b \n            where b.owner = '{schema_name}'\n                and b.table_name not like 'BIN$%' \n                and b.constraint_type = 'P'\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "主键是关系型数据库中唯一确定一条记录的依据,可强制表的实体完整性",
        "solution": [
            "创建表时应定义一个字段为主键"
        ],
        "weight": 1.0,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TABLE_COL_NUM",
        "desc": "大于阀值数量字段的表",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [
            {
                "name": "column_count",
                "desc": "字段数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 60
            }
        ],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "column_count",
                "desc": "字段数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select table_name, \n            count(1) column_count\n        from dba_tab_cols\n        where owner = '{schema_name}'\n        group by table_name\n        having count(1) > {rule.gip('column_count')}\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "表字段数量过多，往往会导致一个数据块存放的行数越少，因此读取数据时IO发生次数越多",
        "solution": [
            "表设计时尽量符合三范式来避免数据冗余,使用频率低的字段拆到另外一张表,必要时做表关联取数"
        ],
        "weight": 1.0,
        "max_score": 5,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "COUNT_RECORD_TAB",
        "desc": "单表或单分区记录数量过大",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [
            {
                "name": "record_count",
                "desc": "记录数",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 10000000
            }
        ],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "record_count",
                "desc": "数据量",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select t.table_name,\n            t.num_rows record_count\n        from DBA_TABLES t  \n        where t.partitioned='NO' \n            and t.owner='{schema_name}' \n            and t.num_rows > {rule.gip('record_count')}\n        union \n            select t.table_name||'.'||t.table_name||':'||t.PARTITION_NAME,\n                    t.num_rows  \n                from  dba_tab_PARTITIONS t  \n                where t.table_owner='{schema_name}'\n                    and t.num_rows > {rule.gip('record_count')}\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "表的规模过大,将影响表的访问效率、增加维护成本等",
        "solution": [
            "1.建议分库,分表,分区",
            "2.历史数据归档"
        ],
        "weight": 0.5,
        "max_score": 3,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_CPU_TIME",
        "desc": "SQL消耗CPU时间过长",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "SQL",
            "SQL_STAT"
        ],
        "input_params": [
            {
                "name": "cpu_time",
                "desc": "cpu时间",
                "unit": "秒",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 100
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_stat_qs = kwargs[\"sql_stat_qs\"]\n\n    qs = sql_stat_qs.filter(per_cpu_time__gte=rule.gip(\"cpu_time\"))\n\n    for d in values_dict(qs,\n                         \"sql_id\",\n                         \"plan_hash_value\"):\n        yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "SQL执行消耗cpu时间过长",
        "solution": [
            "1.对sql执行计划进行分析并进行优化",
            "2.SQL执行次数是否合理"
        ],
        "weight": 0.1,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_ELAPSED_TIME",
        "desc": "SQL执行时间过长",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "SQL",
            "SQL_STAT"
        ],
        "input_params": [
            {
                "name": "elapsed_time",
                "desc": "执行时间",
                "unit": "秒",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 100
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_stat_qs = kwargs[\"sql_stat_qs\"]\n\n    qs = sql_stat_qs.filter(per_elapsed_time__gte=rule.gip(\"elapsed_time\"))\n\n    for d in values_dict(qs,\n                         \"sql_id\",\n                         \"plan_hash_value\"):\n        yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "sql执行时间过长",
        "solution": [
            "对sql执行次数评估是否合理,能否优化"
        ],
        "weight": 0.1,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_DISK_READS",
        "desc": "SQL消耗物理读过高",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "SQL",
            "SQL_STAT"
        ],
        "input_params": [
            {
                "name": "disk_reads",
                "desc": "磁盘读",
                "unit": "bytes",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 1000
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_stat_qs = kwargs[\"sql_stat_qs\"]\n\n    qs = sql_stat_qs.filter(per_disk_reads__gte=rule.gip(\"disk_reads\"))\n\n    for d in values_dict(qs,\n                         \"sql_id\",\n                         \"plan_hash_value\"):\n        yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "disk_reads量大",
        "solution": [
            "对sql消耗资源评估是否合理,能否优化"
        ],
        "weight": 0.1,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "IDX_PARALLEL_ON",
        "desc": "索引对象开启并行度",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_INDEX"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "index_name",
                "desc": "索引名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "index_type",
                "desc": "索引类型",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "parallel_count",
                "desc": "并行度",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": true
            },
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select index_name, type as index_type, degree as parallel_count, table_name  \n        from (\n            select \n                    distinct t.owner||'.'||t.INDEX_NAME as INDEX_NAME ,\n                    decode(INDEX_TYPE,  'NORMAL',  'B-tree',  decode(index_type,  'BITMAP',  'BitMap',  decode(INDEX_TYPE,  'FUNCTION-BASED NORMAL', 'Func',  decode(table_type,  'IOT',  'IOT',  decode(index_type,  'LOB',  'Lob'))))) as type,\n                    t.TABLE_NAME,  \n                    t.degree   \n                from dba_indexes t  \n                where t.index_name not like 'BIN%'  \n                    and t.owner = '{schema_name}'\n                    and to_number(replace(ltrim(t.degree),'DEFAULT',0)) >1  \n                order by t.table_name, t.owner||'.'||t.index_name\n        )\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "当索引被并发访问时，会引起资源竞争",
        "solution": [
            "关闭索引的并行度，默认为1"
        ],
        "weight": 0.5,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "SQL_DIRECT_WRITES",
        "desc": "SQL直接路径写过高",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "SQL",
            "SQL_STAT"
        ],
        "input_params": [
            {
                "name": "direct_writes",
                "desc": "直接路径写数据量",
                "unit": "bytes",
                "data_type": "INT",
                "_cls": "RuleInputParams",
                "value": 1000
            }
        ],
        "output_params": [
            {
                "name": "sql_id",
                "desc": "SQL ID",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "plan_hash_value",
                "desc": "执行计划ID",
                "unit": "",
                "data_type": "INT",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\nfrom rule.code_utils import *\n\n\ndef code(rule, entries, **kwargs):\n    sql_stat_qs = kwargs[\"sql_stat_qs\"]\n\n    qs = sql_stat_qs.filter(per_direct_writes__gte=rule.gip(\"direct_writes\"))\n\n    for d in values_dict(qs,\n                         \"sql_id\",\n                         \"plan_hash_value\"):\n        yield d\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "direct_wirtes 量大",
        "solution": [
            "对sql消耗资源评估是否合理,能否优化"
        ],
        "weight": 0.1,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TABLE_FK_NOIND",
        "desc": "外键没有索引的表",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名称",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "column_name",
                "desc": "字段名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    with tc as (\n        select table_name, column_name \n            from dba_cons_columns \n            where owner||'.'||constraint_name in (\n                select owner||'.'||constraint_name \n                    from dba_constraints \n                    where owner = '{schema_name}' \n                        and constraint_type = 'R')  \n                        and owner = '{schema_name}')\n    select table_name, column_name  \n        from tc  \n        where (table_name, column_name) not in (\n            select table_name, column_name  \n                from tc intersect   select table_name, column_name \n                    from dba_ind_columns  \n                    where index_owner = '{schema_name}')\n    \"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "存在外键约束时，当对主表的记录进行update或delete时，为了校验从表上是否存在依赖该记录的数据，如果从表上外键上不存在索引，则需要在从表增加表锁，此时从表的增删改将被阻塞，业务将被阻塞",
        "solution": [
            "外键必须建立索引"
        ],
        "weight": 1.0,
        "max_score": 10,
        "level": 2,
        "db_model": "OLTP"
    },
    {
        "name": "TABLE_NO_INDEX",
        "desc": "没有索引",
        "db_type": "oracle",
        "entries": [
            "ONLINE",
            "OBJECT",
            "OBJECT_TABLE"
        ],
        "input_params": [
            {
                "name": "tab_phy_size",
                "desc": "表大小",
                "unit": "MB",
                "data_type": "NUM",
                "_cls": "RuleInputParams",
                "value": 10240
            }
        ],
        "output_params": [
            {
                "name": "table_name",
                "desc": "表名",
                "unit": "",
                "data_type": "STR",
                "_cls": "RuleOutputParams",
                "optional": false
            },
            {
                "name": "table_size",
                "desc": "表大小",
                "unit": "",
                "data_type": "NUM",
                "_cls": "RuleOutputParams",
                "optional": false
            }
        ],
        "code": "# Author: kk.Fang(fkfkbill@gmail.com)\n\n\ndef code(rule, entries, **kwargs):\n    schema_name: str = kwargs[\"schema_name\"]\n    cmdb_connector = kwargs[\"cmdb_connector\"]\n\n    sql = f\"\"\"\n    select a.table_name, b.bytes / 1024 / 1024 table_size\n        from dba_tables a, dba_segments b\n        where a.table_name = b.segment_name\n            and b.segment_type IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')\n            AND b.owner = '{schema_name}'\n            AND b.segment_name NOT LIKE 'BIN%'\n            and b.bytes / 1024 / 1024 >= {rule.gip('tab_phy_size')}\n            and a.table_name not in (\n                select table_name from dba_indexes)\n\"\"\"\n    for i in cmdb_connector.select_dict(sql):\n        yield i\n\n\ncode_hole.append(code)\n",
        "status": true,
        "summary": "表的规模过大,且没任何索引时，任何查询都是全表扫描",
        "solution": [
            "根据谓词条件的选择率创建合适的索引"
        ],
        "weight": 0.1,
        "max_score": 3,
        "level": 2,
        "db_model": "OLTP"
    }
]